package newandroid.zhongtuobang.com.neoandroiddemo

import android.os.Build
import android.support.annotation.RequiresApi
import neowallet.Neowallet
import neowallet.Wallet
import newandroid.zhongtuobang.com.neoandroiddemo.crypto.Decryptor
import newandroid.zhongtuobang.com.neoandroiddemo.crypto.EncryptedSettingsRepository
import newandroid.zhongtuobang.com.neoandroiddemo.crypto.EncryptedSettingsRepository.setProperty
import newandroid.zhongtuobang.com.neoandroiddemo.crypto.Encryptor
import java.security.SecureRandom

/**
 * Created by litao on 2018/1/24.
 * 账户管理
 */
object Account {
    private var wallet: Wallet? = null
    private var sharedSecretPieceOne: String? = null

    @RequiresApi(Build.VERSION_CODES.M)
    private fun storeEncryptedKeyOnDevice() {//本地存储
        val wif = wallet!!.wif
        val encryptor = Encryptor()
        val alias = "MyKey"
        val encryptedWIF = encryptor.encryptText(alias, wif)!!

        val iv = encryptor.getIv()!!
        setProperty(alias, encryptedWIF.toHex(), iv, NeoAndroidDemo.appContext!!)
    }

    @RequiresApi(Build.VERSION_CODES.M)
    fun storeColdStorageKeyFragmentOnDevice(keyFragment: String) {//存储冷钱包
        val alias = "Cold Storage Key Fragment"
        val encryptor = Encryptor()
        val encryptedFragment = encryptor.encryptText(alias, keyFragment)!!
        val iv = encryptor.getIv()!!
        setProperty(alias, encryptedFragment.toHex(), iv, NeoAndroidDemo.appContext!!)
    }

    fun getColdStorageKeyFragmentOnDevice(): String {//获取信息
        val alias = "Cold Storage Key Fragment"
        val storedVal = EncryptedSettingsRepository.getProperty(alias, NeoAndroidDemo.appContext!!)
        if (storedVal?.data == null) {
            return ""
        }
        val storedEncryptedFragment = storedVal?.data?.hexStringToByteArray()
        if (storedEncryptedFragment == null || storedEncryptedFragment.size == 0) {
            return ""
        }
        val storedIv = storedVal?.iv!!
        val decrypted = Decryptor().decrypt(alias, storedEncryptedFragment, storedIv)
        return decrypted
    }

    @RequiresApi(Build.VERSION_CODES.M)
    fun removeColdStorageKeyFragment() {    //移除
        storeColdStorageKeyFragmentOnDevice("")
    }

    fun isEncryptedWalletPresent(): Boolean {//是否在线
        val alias = "MyKey"
        val storedVal = EncryptedSettingsRepository.getProperty(alias, NeoAndroidDemo.appContext!!)
        if (storedVal?.data == null) {
            return false
        }
        val storedEncryptedWIF = storedVal?.data?.hexStringToByteArray()
        if (storedEncryptedWIF == null || storedEncryptedWIF.size == 0) {
            return false
        }
        return true
    }

    fun restoreWalletFromDevice() {  //从设备中恢复钱包
        val alias = "MyKey"
        val storedVal = EncryptedSettingsRepository.getProperty(alias, NeoAndroidDemo.appContext!!)
        val storedEncryptedWIF = storedVal?.data?.hexStringToByteArray()!!
        val storedIv = storedVal?.iv!!
        val decrypted = Decryptor().decrypt(alias, storedEncryptedWIF, storedIv)
        wallet = Neowallet.generateFromWIF(decrypted)
    }

    @RequiresApi(Build.VERSION_CODES.M)
    fun createNewWallet() {   //新建钱包
        val random = SecureRandom()
        var bytes = ByteArray(32)
        random.nextBytes(bytes)
        val hex = bytes.toHex()
        wallet = Neowallet.generatePublicKeyFromPrivateKey(hex)
        storeEncryptedKeyOnDevice()
    }

    fun deleteKeyFromDevice() {   //删除Key
        val alias = "MyKey"
        setProperty(alias, "", kotlin.ByteArray(0), NeoAndroidDemo.appContext!!)
    }

    @RequiresApi(Build.VERSION_CODES.M)
    fun fromWIF(wif: String): Boolean {
        //Java does not support multiple return values from function.
        //The function that is generated by go mobile bind. If the second return value is Error type, it will throw the generic exception
        try {
            wallet = Neowallet.generateFromWIF(wif)
        } catch (e: Exception) {
            return false
        }

        storeEncryptedKeyOnDevice()
        return true
    }

    fun getWallet(): Wallet? {
//        restoreWalletFromDevice()
        return wallet
    }
}